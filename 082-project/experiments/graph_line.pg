##DESCRIPTION
##  Missouri Western State University, Finite Mathematics Homework
##ENDDESCRIPTION

##KEYWORDS('Finite Mathematics', 'Linear Equations', 'MWSU')

## DBsubject('Finite Mathematics')
## DBchapter('Linear Equations and Inequalities')
## DBsection('Inequalities in One Variable')
## Date('09/07/2014')
## Author('Glenn Rice')
## Institution('Missouri Western State University')
## ProblemTester('')
## TitleText1('Finite Math')
## Publisher('')
## EditionText1('1')
## AuthorText1('Rice, Klassen, Hegeman')
## Section1('1.2')
## Problem1('12')

################################################################################################
# Setup and Macros
################################################################################################
DOCUMENT();      

loadMacros(
    "PGstandard.pl",
    "MathObjects.pl",
    "PGML.pl",
    "problemRandomize.pl"
);

################################################################################################
# Variables, Formulas, and Graphs
################################################################################################
TEXT(beginproblem());

Context("Matrix");

$x1 = random(-10, 9);
$x2 = random($x1 + 1, 10); # TODO:  Allow vertical lines
$y1 = random(-10, 10);
$y2 = random(-10, 10);

$answer = Compute("[[$x1, $y1],[$x2, $y2]]");

# Custom answer checker that checks to see if a point is on the line
sub correct_line
{
    my ($correct, $student, $ansHash) = @_;
    my $Mcor = $correct->value;
    my $M = $student->value;
    if (norm(Vector($M->row(1)) - Vector($M->row(2)) < 0.1) {
        Value-Error("The two given points are to close to each other");
        return 0;
    }
    my $cx1 = Mcor->element(1,1);
    my $cy1 = Mcor->element(1,2);
    my $cx2 = Mcor->element(2,1);
    my $cy2 = Mcor->element(2,2);
    my $m = ($cy2 - $cy1) / ($cx2 - $cx1);
    my $b = $cy1 - $slope * $cx1;
    if (norm($m*Vector(M->column(1)) + Vector($b,$b) - Vector(M->column(2))) < 0.1) { return 1; }
    Value->Error("This is not the correct line!");
    return 0;
}

################################################################################################
# Main Text
################################################################################################
Context()->texStrings;
Context()->operators->undefine("+","-","*","/");

HEADER_TEXT(<<EOF);
<link rel='stylesheet' type='text/css' href='https://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css' media='screen' />
<script type='text/javascript' src='https://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js'></script>
EOF

TEXT(NAMED_HIDDEN_ANS_RULE('point_matrix_ans', 60));

BEGIN_PGML
Graph the line passing through the points [`([$x1], [$y1])`] and [`([$x2], [$y2])`].
END_PGML

TEXT(MODES(TeX=>"", HTML=><<'END_TEXT'));
<p id="point1">A: </p>
<p id="point2">B: </p>

<pre>
<div id='box' class='jxgbox' style='width:440px; height:440px;'></div>
<script type='text/javascript'>

function updateText()
{
    if (typeof(point1) != "undefined")
    {
        document.getElementById('point1').innerHTML =
            point1.name + ": (" + point1.X().toFixed(2) + ", " + point1.Y().toFixed(2) + ")";
    }

    if (typeof(point2) != "undefined")
    {
        document.getElementById('point2').innerHTML =
            point2.name + ": (" + point2.X().toFixed(2) + ", " + point2.Y().toFixed(2) + ")";
    }

    if ((typeof(point1) != "undefined") && (typeof(point2) != "undefined"))
    {
        document.getElementById('point_matrix_ans').value =
            "[[" + point1.X().toFixed(2) + ", " + point1.Y().toFixed(2) + "]," + 
            "[" + point2.X().toFixed(2) + ", " + point2.Y().toFixed(2) + "]]";
    }
}

function getMouseCoords(e)
{
    var i;
    if (e[JXG.touchProperty])
    {
        // index of the finger that is used to extract the coordinates
        i = 0;
    }

    var cPos = brd.getCoordsTopLeftCorner(e, i),
        absPos = JXG.getPosition(e, i),
        dx = absPos[0] - cPos[0],
        dy = absPos[1] - cPos[1];

    return new JXG.Coords(JXG.COORDS_BY_SCREEN, [dx, dy], brd);
};

function createPointOne(e)
{
    var coords = getMouseCoords(e);

    point1 = brd.create('point', [coords.usrCoords[1], coords.usrCoords[2]], {style:6});
    point1.on('down', updateText);
    point1.on('over', updateText);
    point1.on('drag', updateText);

    brd.off('down');
    brd.on('down', createPointTwo);

    updateText();
    brd.update();
};

function createPointTwo(e)
{
    var coords = getMouseCoords(e);

    if (JXG.Math.Geometry.distance(point1.coords.usrCoords, coords.usrCoords) < .2){
        return;
    }

    point2 = brd.create('point', [coords.usrCoords[1], coords.usrCoords[2]], {style:6});
    point2.on('down', updateText);
    point2.on('over', updateText);
    point2.on('drag', updateText);

    line1 = brd.create('line', [point1, point2]);
    line1.on('move', updateText);
    line1.on('drag', updateText);

    brd.off('down');

    updateText();
    brd.update();
};

var brd = JXG.JSXGraph.initBoard('box', {axis: true, originX: 220, originY: 220, unitX: 20, unitY: 20});
brd.suspendUpdate();

brd.create('grid', []);

var current_pos_text = brd.create('text', [10.5, -10, ""], {anchorX:'right', anchorY:'bottom', cssClass:'mytext'});

brd.on('move', function(e) {
    var coords = getMouseCoords(e);
    current_pos_text.setText("(" + coords.usrCoords[1].toFixed(2) + ", " + coords.usrCoords[2].toFixed(2) + ")");
}
);

var point1, point2, line1;

// Restore data from previous attempts if available
var points_data = document.getElementById('point_matrix_ans').value.replace(/[[]]*/g, '').split(",");
if (points_data.length > 3)
{
    point1 = brd.create('point', [parseFloat(points_data[0]), parseFloat(points_data[1])], {style:6});
    point1.on('down', updateText);
    point1.on('over', updateText);
    point1.on('drag', updateText);

    point2 = brd.create('point', [parseFloat(points_data[2]), parseFloat(points_data[3])], {style:6});
    point2.on('down', updateText);
    point2.on('over', updateText);
    point2.on('drag', updateText);

    line1 = brd.create('line', [point1, point2]);
    line1.on('move', updateText);
    line1.on('drag', updateText);
}

updateText();

if (typeof(point1) == "undefined")
brd.on('down', createPointOne);
else if (typeof(point2) == "undefined")
brd.on('down', createPointTwo);

brd.unsuspendUpdate();

</script>
</pre>
END_TEXT

NAMED_ANS('point_matrix_ans'=>$answer->cmp(checker=>~~&correct_line));

ENDDOCUMENT();
